var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DifferentiableHarmonics","category":"page"},{"location":"#DifferentiableHarmonics.jl","page":"Home","title":"DifferentiableHarmonics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is spun of QG3.jl to give a stand-alone implementation of reverse-mode differentiable spherical harmonics transforms and derivative operators that work on CUDA GPUs and CPU. All implementations are checked again finite difference implenations and the transforms of SpeedyWeather.jl.","category":"page"},{"location":"#How-to","page":"Home","title":"How-to","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each of the transforms and derivatives needs to be pre-planned. The common parameters of these plans are hold in HarmonicsParameters. First, we can plan transforms for a quadratic FullGaussianGrid with truncation at the 21st wave number","category":"page"},{"location":"","page":"Home","title":"Home","text":"L_max = 21\np = HarmonicsParameters(L_max, GPU=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we generate some random fields in both the spectral and grid domain:: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = rand_grid(p)\nB = rand_SH(p)\n\n# batched matrices with trailing dimensions can be declared by:\nA_b = rand_grid(p, N_channels, N_batch) # N_lat x N_lon x N_channels x N_batch\nB_b = rand_SH(p,  N_channels, N_batch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can preplan all derivatives and transforms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"dλ = Derivative_dλ(p, N_batch=N_batch)\ndμ = GaussianGrid_dμ(p, N_channels, N_batch)\nL = Laplacian(p, init_inverse=true, N_batch=N_batch)\nanalysis_plan = SHtoGaussianGridTransform(p, N_channels, N_batch)\nsynthesis_plan = GaussianGridtoSHTransform(p, N_channels, N_batch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And apply to plans like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"transform_grid(B_b, analysis_plan) # SH -> grid \ntransform_grid(A_b, synthesis_plan) # grid -> SH \nΔ(B_b, L) # SH -> Laplacian(SH)\nSHtoGrid_dθ(B_b, dμ) # SH -> d B / dθ   colatitude\nSHtoGrid_dμ(B_b, dμ) # SH -> d B / dμ   (μ = sin(lat))\nSHtoGrid_dλ(B_b, dλ) # SH -> d B / dλ   longitutde","category":"page"},{"location":"#Harmonics-Coefficients","page":"Home","title":"Harmonics Coefficients","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The harmonics coefficents are saved in the following format: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"show(sph_modes(p))","category":"page"},{"location":"#Work-in-Progress","page":"Home","title":"Work in Progress","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the future, this will be replaced by SpeedyWeather.jl's SpeedyTransform, but so far it is not differentiable yet. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DifferentiableHarmonics]","category":"page"},{"location":"#DifferentiableHarmonics.AbstractSHTransform","page":"Home","title":"DifferentiableHarmonics.AbstractSHTransform","text":"abstract type AbstractSHTransform{onGPU}\n\nRequired fields for all subtypes: \n\noutputsize\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.AbstractμDerivative","page":"Home","title":"DifferentiableHarmonics.AbstractμDerivative","text":"Required fields: \n\nmsinθ: To change between μ and latitude derivative (-sin(colats))\nmsinθ_3d: To change between μ and latitude derivative (-sin(colats))\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.Derivative_dλ-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}} where T","page":"Home","title":"DifferentiableHarmonics.Derivative_dλ","text":"Derivative_dλ(\n    p::HarmonicsParameters{T};\n    N_batch\n) -> Derivative_dλ\n\n\nPre-computes Derivatives by longitude. Uses the SH relation, is therefore independ from the grid.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.GaussianGrid_dμ-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Int64}, Tuple{HarmonicsParameters{T}, Int64, Int64}} where T","page":"Home","title":"DifferentiableHarmonics.GaussianGrid_dμ","text":"GaussianGrid_dμ(\n    p::HarmonicsParameters{T}\n) -> GaussianGrid_dμ{_A, SHtoGaussianGridTransform{R, S, T, FT, U, TU, I, onGPU}} where {_A, R, S, T, FT, U, TU, I<:Integer, onGPU}\nGaussianGrid_dμ(\n    p::HarmonicsParameters{T},\n    N_channels::Int64\n) -> GaussianGrid_dμ{_A, SHtoGaussianGridTransform{R, S, T, FT, U, TU, I, onGPU}} where {_A, R, S, T, FT, U, TU, I<:Integer, onGPU}\nGaussianGrid_dμ(\n    p::HarmonicsParameters{T},\n    N_channels::Int64,\n    N_batch::Int64\n) -> GaussianGrid_dμ{_A, SHtoGaussianGridTransform{R, S, T, FT, U, TU, I, onGPU}} where {_A, R, S, T, FT, U, TU, I<:Integer, onGPU}\n\n\nPre-computes Pseudo-spectral approach to computing derivatives with repsect to μ = sin(lats). Derivatives are called with following the naming scheme: \"Domain1Input\"to\"Domain2Output\"_d\"derivativeby\"\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.GaussianGridtoSHTransform","page":"Home","title":"DifferentiableHarmonics.GaussianGridtoSHTransform","text":"GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.GaussianGridtoSHTransform-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Int64}, Tuple{HarmonicsParameters{T}, Int64, Int64}} where T","page":"Home","title":"DifferentiableHarmonics.GaussianGridtoSHTransform","text":"(\n\nGaussianGridtoSHTransform(\n    p::HarmonicsParameters{T}\n) -> GaussianGridtoSHTransform{_A, _B, _C, _D, <:AbstractArray{T, 3}, Tuple{Int64, Int64}} where {_A, _B, _C, _D, T<:Number}\nGaussianGridtoSHTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64\n) -> GaussianGridtoSHTransform{_A, _B, _C, _D, <:AbstractArray{T, 3}, Tuple{Int64, Int64}} where {_A, _B, _C, _D, T<:Number}\nGaussianGridtoSHTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64,\n    N_batch::Int64\n) -> GaussianGridtoSHTransform{_A, _B, _C, _D, <:AbstractArray{T, 3}, Tuple{Int64, Int64}} where {_A, _B, _C, _D, T<:Number}\n\n\n)\n\nReturns transform struct, that can be used with transform_SH. Transforms Gaussian Grid data to real spherical harmonics coefficients that follow the coefficient logic explained in the main documenation.\n\nAdditional input arguments:\n\nN_channels: defines the transform for N_channel horizontal/channel levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.HarmonicsParameters","page":"Home","title":"DifferentiableHarmonics.HarmonicsParameters","text":"HarmonicsParameters(\n    Lmax::Integer;\n    ...\n) -> HarmonicsParameters{Float32, _A, <:Tuple{Any, Any}} where _A\nHarmonicsParameters(\n    Lmax::Integer,\n    antialiasing::Symbol;\n    eltype,\n    GPU\n) -> HarmonicsParameters{Float32, _A, <:Tuple{Any, Any}} where _A\n\n\nInitializes the HarmonicsParameters based on a standard triangular truncation, :quadratic or :cubic antialiasing and Gaussian latitudes. \n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.HarmonicsParameters-2","page":"Home","title":"DifferentiableHarmonics.HarmonicsParameters","text":"Holds all parameters for the spherical harmonics. L and M are the number of harmonics numbers. L_max is the largest value of l.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.HarmonicsParameters-Union{Tuple{T}, Tuple{Integer, AbstractVector{T}, AbstractVector{T}}} where T","page":"Home","title":"DifferentiableHarmonics.HarmonicsParameters","text":"HarmonicsParameters(\n    Lmax::Integer,\n    lats::AbstractArray{T, 1},\n    lons::AbstractArray{T, 1};\n    GPU\n)\n\n\nInitializes the HarmonicsParameters based on a standard triangular truncation and the grid handed over. \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.Laplacian-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}} where T","page":"Home","title":"DifferentiableHarmonics.Laplacian","text":"Laplacian(\n    p::HarmonicsParameters{T};\n    init_inverse,\n    R,\n    N_batch,\n    kwargs...\n) -> Laplacian\n\n\nInitializes the Laplacian in spherical harmonics and if init_inverse==true also its inverse\n\nApply the Laplacian with the functions (@ref)[Δ] and (@ref)[Δ⁻¹]\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGaussianGridTransform-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Int64}, Tuple{HarmonicsParameters{T}, Int64, Int64}} where T","page":"Home","title":"DifferentiableHarmonics.SHtoGaussianGridTransform","text":"SHtoGaussianGridTransform(\n    p::HarmonicsParameters{T}\n) -> SHtoGaussianGridTransform{_A, _B, _C, _D, _E, Tuple{Int64, Int64}, Int64} where {_A, _B, _C, _D, _E}\nSHtoGaussianGridTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64\n) -> SHtoGaussianGridTransform{_A, _B, _C, _D, _E, Tuple{Int64, Int64}, Int64} where {_A, _B, _C, _D, _E}\nSHtoGaussianGridTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64,\n    N_batch::Int64\n) -> SHtoGaussianGridTransform{_A, _B, _C, _D, _E, Tuple{Int64, Int64}, Int64} where {_A, _B, _C, _D, _E}\n\n\nReturns transform struct, that can be used with transform_grid. Transforms real spherical harmonics coefficients to Gaussian grid data, follows the coefficient logic explained in the main documenation.\n\nN_channel: defines the transform for N_channel horizontal levels. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted and only 2D and 3D input will work\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SH_mask-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.SH_mask","text":"(\n\nSH_mask(p::HarmonicsParameters) -> Any\n\n\n) Returns a Boolean array with all entries that represent SPH coefficents true\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGrid_dθ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, DifferentiableHarmonics.AbstractμDerivative}} where T","page":"Home","title":"DifferentiableHarmonics.SHtoGrid_dθ","text":"SHtoGrid_dθ(\n    ψ::AbstractArray{T, 2},\n    d::DifferentiableHarmonics.AbstractμDerivative\n) -> Any\n\n\nderivative of input after θ (azimutal angle/colatitude) in SH, uses pre computed SH evaluations (dependend on the grid type)\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGrid_dλ-Tuple{Any, Any, Any}","page":"Home","title":"DifferentiableHarmonics.SHtoGrid_dλ","text":"SHtoGrid_dλ(ψ, dl, sh2g) -> Any\n\n\nDerivative of input after φ (polar angle) or λ (longtitude) in SH to Grid\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGrid_dμ-Tuple{Any, GaussianGrid_dμ}","page":"Home","title":"DifferentiableHarmonics.SHtoGrid_dμ","text":"SHtoGrid_dμ(ψ, d::GaussianGrid_dμ) -> Any\n\n\nDerivative of input after μ = sinϕ in SH, uses pre computed SH evaluations\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGrid_dφ-Tuple{Any, Derivative_dλ, DifferentiableHarmonics.AbstractSHtoGridTransform}","page":"Home","title":"DifferentiableHarmonics.SHtoGrid_dφ","text":"SHtoGrid_dφ(\n    ψ,\n    dλ::Derivative_dλ,\n    sh2g::DifferentiableHarmonics.AbstractSHtoGridTransform\n) -> Any\n\n\nDerivative of input after φ (polar angle) or λ (longtitude) in SH to Grid\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGrid_dϕ-Tuple{Any, Any}","page":"Home","title":"DifferentiableHarmonics.SHtoGrid_dϕ","text":"SHtoGrid_dϕ(ψ, m) -> Any\n\n\nDerivative of input after ϕ - latitude in SH, uses pre computed SH evaluations\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoSH_dλ-Tuple{Any, Any}","page":"Home","title":"DifferentiableHarmonics.SHtoSH_dλ","text":"SHtoSH_dλ(ψ, m) -> Any\n\n\nDerivative of input after φ (polar angle/longtitude) in SH, output in SH\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.change_msign-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}}} where T","page":"Home","title":"DifferentiableHarmonics.change_msign","text":"change_msign(\n    A::AbstractArray{T, 2},\n    swap_array::AbstractVector{Int64}\n) -> Any\n\n\nChange the sign of the m in SH. This version returns a view\n\nthere is currently a bug or at least missing feature in Zygote, the AD library, that stops views from always working flawlessly when a view is mixed with prior indexing of an array. We need a view for the derivative after φ to change the sign of m, so here is a differentiable variant of the SHtoSH_dφ function for the 2d field\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_GaussWeights-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Any}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_GaussWeights","text":"(\n\ncompute_GaussWeights(\n    p::HarmonicsParameters{T<:Number}\n) -> Any\ncompute_GaussWeights(\n    p::HarmonicsParameters{T<:Number},\n    reltol\n) -> Any\n\n\n) Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_LegendreGauss-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, AbstractArray{T, 3}, AbstractVector{T}}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_LegendreGauss","text":"(\n\ncompute_LegendreGauss(\n    p::HarmonicsParameters{T<:Number},\n    P::AbstractArray{T<:Number, 3},\n    w::AbstractArray{T<:Number, 1}\n) -> AbstractArray{T, 3} where T<:Number\n\n\n)\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_LegendreGauss-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, AbstractArray{T, 3}}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_LegendreGauss","text":"(\n\ncompute_LegendreGauss(\n    p::HarmonicsParameters{T<:Number},\n    P::AbstractArray{T<:Number, 3};\n    reltol\n) -> AbstractArray{T, 3} where T<:Number\n\n\n)\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_P-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_P","text":"compute_P(\n    p::HarmonicsParameters{T<:Number};\n    sh_norm,\n    CSPhase,\n    prefactor\n) -> Tuple{Any, Any}\n\n\nPre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL\n\nm values are stored 0,1,2,3,4,5,6,7, ...l_max, 0 (nothing),-1, -2, -3, (on GPU)  (the second 0 is the Imanigary part / sin part of the fourier transform which is always identical to zero, it is kept here to have equal matrix sizes)\n\nso far only |m| is used, as I assume real SPH.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_Δ-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_Δ","text":"compute_Δ(p::HarmonicsParameters{T<:Number}) -> Any\n\n\nPre-compute the Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_Δ⁻¹-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_Δ⁻¹","text":"compute_Δ⁻¹(p::HarmonicsParameters{T<:Number}) -> Any\n\n\nPre-compute the inverse Laplacian in Spherical Harmonics, follows the matrix convention of FastTransforms.jl\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.lMatrix-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.lMatrix","text":"(\n\nlMatrix(p::HarmonicsParameters) -> Any\n\n\n)\n\nReturns the order numbers l of the SPH coefficents. \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.mMatrix-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.mMatrix","text":"(\n\nmMatrix(p::HarmonicsParameters) -> Any\n\n\n)\n\nReturns the order numbers m of the SPH coefficents. \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.no_SH_mask-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.no_SH_mask","text":"(\n\nno_SH_mask(p::HarmonicsParameters) -> Any\n\n\n) Returns a Boolean array with all entries that don't represent SPH coefficents true\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.plan_ir2r_AD","page":"Home","title":"DifferentiableHarmonics.plan_ir2r_AD","text":"plan_ir2r_AD(arr::AbstractArray{T,N}, dims=1)\n\nReturns an inverse R2R half-complex format FFT plan (HC2R) along dimension dims. Incontrast to the FFTW.R2R plan this assumes both the real and imaginary part in ascending order, so (Re(f0), Re(f1), .... , Im(f0), Im(f1), ...\n\nSimilar to the R2R plan, this plan is not normalized. For a normaliziation you have to divide by the number of elements in the dimension you apply the plan to. \n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.plan_r2r_AD","page":"Home","title":"DifferentiableHarmonics.plan_r2r_AD","text":"plan_r2r_AD(arr::AbstractArray{T,N}, dims=1)\n\nReturns a R2R half-complex format FFT plan (R2HC) along dimension dims. Incontrast to the FFTW.R2R plan this returns both the real and imaganiary part in ascending order, so (Re(f0), Re(f1), .... , Im(f0), Im(f1), ...\n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.rand_SH-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.rand_SH","text":"(\n\nrand_SH(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a random array with the correct shape to represend the SH domain and on the correct device and eltype. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.rand_grid-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, DifferentiableHarmonics.AbstractSHtoGridTransform, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.rand_grid","text":"(\n\nrand_grid(\n    p::HarmonicsParameters{T},\n    analysis_plan::DifferentiableHarmonics.AbstractSHtoGridTransform,\n    size...\n) -> Any\n\n\n) Generate a zero array with the correct shape to represend the grid domain and on the correct device and eltype, the same spectral truncation as defined in p is applied. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.rand_grid-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.rand_grid","text":"(\n\nrand_grid(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a zero array with the correct shape to represend the grid domain and on the correct device and eltype, the same spectral truncation as defined in p is applied. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.sph_modes-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.sph_modes","text":"(\n\nsph_modes(p::HarmonicsParameters) -> Any\n\n\n)\n\nReturns a matrix with the SPH modes (l, m) arranged as they are in all SH domain matrices in DifferentiableHarmonics.jl\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.transform_SH","page":"Home","title":"DifferentiableHarmonics.transform_SH","text":"transform_SH(data::AbstractArray{T,N}, t::GaussianGridtoSHTransform)\n\nTransforms data into the spherical harmonics domain. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.transform_grid","page":"Home","title":"DifferentiableHarmonics.transform_grid","text":"transform_grid(data::AbstractArray{T,N}, t::SHtoGaussianGridTransform)\n\nTransforms data from the spherical harmonics domain to a Gaussian Grid. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.zeros_SH-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.zeros_SH","text":"(\n\nzeros_SH(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a zero array with the correct shape to represend the SH domain and on the correct device and eltype. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.zeros_grid-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.zeros_grid","text":"(\n\nzeros_grid(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a zero array with the correct shape to represend the grid domain and on the correct device and eltype. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.Δ-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Laplacian{T, M, A1, A2} where {M<:AbstractMatrix{T}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}}} where T","page":"Home","title":"DifferentiableHarmonics.Δ","text":"Δ(\n    ψ::AbstractArray{T, 4},\n    L::Laplacian{T, M, A1, A2} where {M<:AbstractArray{T, 2}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}\n) -> Any\n\n\nApply the Laplacian. Also serves to convert regular vorticity (not the quasigeostrophic one) to streamfunction) \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.Δ⁻¹-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Laplacian{T, M, A1, A2} where {M<:AbstractMatrix{T}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}}} where T","page":"Home","title":"DifferentiableHarmonics.Δ⁻¹","text":"Δ⁻¹(\n    ψ::AbstractArray{T, 4},\n    L::Laplacian{T, M, A1, A2} where {M<:AbstractArray{T, 2}, A1<:AbstractArray{T, 3}, A2<:AbstractArray{T, 3}}\n) -> Any\n\n\nApply the inverse Laplacian. Also serves to convert the streamfunction to regular vorticity \n\n\n\n\n\n","category":"method"}]
}
