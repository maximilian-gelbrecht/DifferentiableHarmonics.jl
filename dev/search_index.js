var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DifferentiableHarmonics","category":"page"},{"location":"#DifferentiableHarmonics.jl","page":"Home","title":"DifferentiableHarmonics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is spun of QG3.jl to give a stand-alone implementation of reverse-mode differentiable spherical harmonics transforms and derivative operators that work on CUDA GPUs and CPU. All implementations are checked again finite difference implenations and the transforms of SpeedyWeather.jl.","category":"page"},{"location":"#How-to","page":"Home","title":"How-to","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each of the transforms and derivatives needs to be pre-planned. The common parameters of these plans are hold in HarmonicsParameters. First, we can plan transforms for a quadratic FullGaussianGrid with truncation at the 21st wave number","category":"page"},{"location":"","page":"Home","title":"Home","text":"L_max = 21\np = HarmonicsParameters(L_max, GPU=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we generate some random fields in both the spectral and grid domain:: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = rand_grid(p)\nB = rand_SH(p)\n\n# batched matrices with trailing dimensions can be declared by:\nA_b = rand_grid(p, N_channels, N_batch) # N_lat x N_lon x N_channels x N_batch\nB_b = rand_SH(p,  N_channels, N_batch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can preplan all derivatives and transforms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"dλ = Derivative_dλ(p, N_batch=N_batch)\ndμ = GaussianGrid_dμ(p, N_channels, N_batch)\nL = Laplacian(p, init_inverse=true, N_batch=N_batch)\nanalysis_plan = SHtoGaussianGridTransform(p, N_channels, N_batch)\nsynthesis_plan = GaussianGridtoSHTransform(p, N_channels, N_batch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And apply to plans like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"transform_grid(B_b, analysis_plan) # SH -> grid \ntransform_grid(A_b, synthesis_plan) # grid -> SH \nΔ(B_b, L) # SH -> Laplacian(SH)\nSHtoGrid_dθ(B_b, dμ) # SH -> d B / dθ   colatitude\nSHtoGrid_dμ(B_b, dμ) # SH -> d B / dμ   (μ = sin(lat))\nSHtoGrid_dλ(B_b, dλ) # SH -> d B / dλ   longitutde","category":"page"},{"location":"#Harmonics-Coefficients","page":"Home","title":"Harmonics Coefficients","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The harmonics coefficents are saved in the following format: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"show(sph_modes(p))","category":"page"},{"location":"#Work-in-Progress","page":"Home","title":"Work in Progress","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the future, this will be replaced by SpeedyWeather.jl's SpeedyTransform, but so far it is not differentiable yet. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DifferentiableHarmonics]","category":"page"},{"location":"#DifferentiableHarmonics.AbstractSHTransform","page":"Home","title":"DifferentiableHarmonics.AbstractSHTransform","text":"abstract type AbstractSHTransform{onGPU}\n\nRequired fields for all subtypes: \n\noutputsize\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.GaussianGridtoSHTransform","page":"Home","title":"DifferentiableHarmonics.GaussianGridtoSHTransform","text":"GaussianGridtoSHTransform(p::QG3ModelParameters{T}, N_level::Int=3; N_batch::Int=0)\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.GaussianGridtoSHTransform-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Int64}, Tuple{HarmonicsParameters{T}, Int64, Int64}} where T","page":"Home","title":"DifferentiableHarmonics.GaussianGridtoSHTransform","text":"(\n\nGaussianGridtoSHTransform(p::HarmonicsParameters{T})\nGaussianGridtoSHTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64\n)\nGaussianGridtoSHTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64,\n    N_batch::Int64\n)\n\n\n)\n\nReturns transform struct, that can be used with transform_SH. Transforms Gaussian Grid data to real spherical harmonics coefficients that follow the coefficient logic explained in the main documenation.\n\nAdditional input arguments:\n\nN_channels: defines the transform for N_channel horizontal/channel levels. Has to be equal to three for the QG3 model itself, but might be different for other applications. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.HarmonicsParameters","page":"Home","title":"DifferentiableHarmonics.HarmonicsParameters","text":"HarmonicsParameters(\n    Lmax::Integer;\n    ...\n) -> HarmonicsParameters{Float32, _A, <:Tuple{Any, Any}} where _A\nHarmonicsParameters(\n    Lmax::Integer,\n    antialiasing::Symbol;\n    eltype,\n    GPU\n) -> HarmonicsParameters{Float32, _A, <:Tuple{Any, Any}} where _A\n\n\nInitializes the HarmonicsParameters based on a standard triangular truncation, :quadratic or :cubic antialiasing and Gaussian latitudes. \n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.HarmonicsParameters-2","page":"Home","title":"DifferentiableHarmonics.HarmonicsParameters","text":"Holds all parameters for the spherical harmonics. L and M are the number of harmonics numbers. L_max is the largest value of l.\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiableHarmonics.HarmonicsParameters-Union{Tuple{T}, Tuple{Integer, AbstractVector{T}, AbstractVector{T}}} where T","page":"Home","title":"DifferentiableHarmonics.HarmonicsParameters","text":"HarmonicsParameters(\n    Lmax::Integer,\n    lats::AbstractArray{T, 1},\n    lons::AbstractArray{T, 1};\n    GPU\n)\n\n\nInitializes the HarmonicsParameters based on a standard triangular truncation and the grid handed over. \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SHtoGaussianGridTransform-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Int64}, Tuple{HarmonicsParameters{T}, Int64, Int64}} where T","page":"Home","title":"DifferentiableHarmonics.SHtoGaussianGridTransform","text":"SHtoGaussianGridTransform(p::HarmonicsParameters{T})\nSHtoGaussianGridTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64\n)\nSHtoGaussianGridTransform(\n    p::HarmonicsParameters{T},\n    N_channels::Int64,\n    N_batch::Int64\n)\n\n\nReturns transform struct, that can be used with transform_grid. Transforms real spherical harmonics coefficients to Gaussian grid data, follows the coefficient logic explained in the main documenation.\n\nN_channel: defines the transform for N_channel horizontal levels. \nN_batch: defines the transforms with an additional batch dimension for ML tasks, if N_batch==0 this is omitted and only 2D and 3D input will work\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.SH_mask-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.SH_mask","text":"(\n\nSH_mask(p::HarmonicsParameters) -> Any\n\n\n) Returns a Boolean array with all entries that represent SPH coefficents true\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_GaussWeights-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}, Tuple{HarmonicsParameters{T}, Any}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_GaussWeights","text":"(\n\ncompute_GaussWeights(\n    p::HarmonicsParameters{T<:Number}\n) -> Any\ncompute_GaussWeights(\n    p::HarmonicsParameters{T<:Number},\n    reltol\n) -> Any\n\n\n) Pre-computes gaussian weights for Legendre Transform, also checks if we really have the correct gaussian latitudes\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_LegendreGauss-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, AbstractArray{T, 3}, AbstractVector{T}}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_LegendreGauss","text":"(\n\ncompute_LegendreGauss(\n    p::HarmonicsParameters{T<:Number},\n    P::AbstractArray{T<:Number, 3},\n    w::AbstractArray{T<:Number, 1}\n) -> AbstractArray{T, 3} where T<:Number\n\n\n)\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_LegendreGauss-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, AbstractArray{T, 3}}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_LegendreGauss","text":"(\n\ncompute_LegendreGauss(\n    p::HarmonicsParameters{T<:Number},\n    P::AbstractArray{T<:Number, 3};\n    reltol\n) -> AbstractArray{T, 3} where T<:Number\n\n\n)\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.compute_P-Union{Tuple{HarmonicsParameters{T}}, Tuple{T}} where T<:Number","page":"Home","title":"DifferentiableHarmonics.compute_P","text":"compute_P(\n    p::HarmonicsParameters{T<:Number};\n    sh_norm,\n    CSPhase,\n    prefactor\n) -> Tuple{Any, Any}\n\n\nPre-compute ass. Legendre Polynomials and dP/dx (derivative of ass. Legendre Polynomial) at the grid points and also the remainder of the Spherical Harmonics at the grid points using GSL\n\nm values are stored 0,1,2,3,4,5,6,7, ...l_max, 0 (nothing),-1, -2, -3, (on GPU)  (the second 0 is the Imanigary part / sin part of the fourier transform which is always identical to zero, it is kept here to have equal matrix sizes)\n\nso far only |m| is used, as I assume real SPH.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.lMatrix-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.lMatrix","text":"(\n\nlMatrix(p::HarmonicsParameters) -> Any\n\n\n)\n\nReturns the order numbers l of the SPH coefficents. \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.mMatrix-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.mMatrix","text":"(\n\nmMatrix(p::HarmonicsParameters) -> Any\n\n\n)\n\nReturns the order numbers m of the SPH coefficents. \n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.no_SH_mask-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.no_SH_mask","text":"(\n\nno_SH_mask(p::HarmonicsParameters) -> Any\n\n\n) Returns a Boolean array with all entries that don't represent SPH coefficents true\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.plan_ir2r_AD","page":"Home","title":"DifferentiableHarmonics.plan_ir2r_AD","text":"plan_ir2r_AD(arr::AbstractArray{T,N}, dims=1)\n\nReturns an inverse R2R half-complex format FFT plan (HC2R) along dimension dims. Incontrast to the FFTW.R2R plan this assumes both the real and imaginary part in ascending order, so (Re(f0), Re(f1), .... , Im(f0), Im(f1), ...\n\nSimilar to the R2R plan, this plan is not normalized. For a normaliziation you have to divide by the number of elements in the dimension you apply the plan to. \n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.plan_r2r_AD","page":"Home","title":"DifferentiableHarmonics.plan_r2r_AD","text":"plan_r2r_AD(arr::AbstractArray{T,N}, dims=1)\n\nReturns a R2R half-complex format FFT plan (R2HC) along dimension dims. Incontrast to the FFTW.R2R plan this returns both the real and imaganiary part in ascending order, so (Re(f0), Re(f1), .... , Im(f0), Im(f1), ...\n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.rand_SH-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.rand_SH","text":"(\n\nrand_SH(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a random array with the correct shape to represend the SH domain and on the correct device and eltype. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.rand_grid-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, SHtoGaussianGridTransform, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.rand_grid","text":"(\n\nrand_grid(\n    p::HarmonicsParameters{T},\n    analysis_plan::SHtoGaussianGridTransform,\n    size...\n) -> Any\n\n\n) Generate a zero array with the correct shape to represend the grid domain and on the correct device and eltype, the same spectral truncation as defined in p is applied. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.rand_grid-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.rand_grid","text":"(\n\nrand_grid(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a zero array with the correct shape to represend the grid domain and on the correct device and eltype, the same spectral truncation as defined in p is applied. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.sph_modes-Tuple{HarmonicsParameters}","page":"Home","title":"DifferentiableHarmonics.sph_modes","text":"(\n\nsph_modes(p::HarmonicsParameters) -> Any\n\n\n)\n\nReturns a matrix with the SPH modes (l, m) arranged as they are in all SH domain matrices in DifferentiableHarmonics.jl\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.transform_SH","page":"Home","title":"DifferentiableHarmonics.transform_SH","text":"transform_SH(data::AbstractArray{T,N}, t::GaussianGridtoSHTransform)\n\nTransforms data into the spherical harmonics domain. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.transform_grid","page":"Home","title":"DifferentiableHarmonics.transform_grid","text":"transform_grid(data::AbstractArray{T,N}, t::SHtoGaussianGridTransform)\n\nTransforms data from the spherical harmonics domain to a Gaussian Grid. The coefficents are ordered in a matrix in coloumns of the m value. On CPU the convention of FastTransform.jl is used (0, -1, 1, -2, 2, ...), on GPU the convention (0, 1, 2, 3, ...., (nothing, -1, -2, -3, ...)). Watch out, in future proabaly this might be standardized. \n\n\n\n\n\n","category":"function"},{"location":"#DifferentiableHarmonics.zeros_SH-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.zeros_SH","text":"(\n\nzeros_SH(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a zero array with the correct shape to represend the SH domain and on the correct device and eltype. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableHarmonics.zeros_grid-Union{Tuple{T}, Tuple{HarmonicsParameters{T}, Vararg{Any}}} where T","page":"Home","title":"DifferentiableHarmonics.zeros_grid","text":"(\n\nzeros_grid(p::HarmonicsParameters{T}, size...) -> Any\n\n\n)\n\nGenerate a zero array with the correct shape to represend the grid domain and on the correct device and eltype. Additional input arguments are appended after the first two leading dimensions\n\n\n\n\n\n","category":"method"}]
}
